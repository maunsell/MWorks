#ifndef EYE_STATUS#define EYE_STATUS#include "GenericData.h"#include "GenericVariable.h"#include "Buffers.h"#include "Filters.h"#include "CoordinateTransform2D.h"#include <math.h>// Eye routinesclass EyeTrigger {	protected:		Variable *x;		Variable *y;		Variable *radius;		Variable *active;		Variable *togglevar;			bool setadditionalvar;		Variable *var;		Data value;    // this wasn't implemented as a template to reduce complexity			public:		EyeTrigger(Variable *_x, Variable *_y, Variable *_radius, Variable *_active, Variable *_togglevar){			x = _x;			y = _y;			radius = _radius;			active = _active;			togglevar = _togglevar;						setadditionalvar = false;			value = -1;		}			EyeTrigger(Variable *_x, Variable *_y, Variable *_radius, Variable *_active, Variable *_togglevar, Variable *_var, Data _value){			x = _x;			y = _y;			radius = _radius;			active = _active;			togglevar = _togglevar;			var = _var;			value = _value;						setadditionalvar = true;		}			bool isActive();		bool isInWindow(float locx, float locy);        bool isAdditionalVarSet();		void update();				float getXDeg();		float getYDeg();		float getRadiusDeg();                Variable * getAdditionalParam();        Data * getAdditionalData();};class SaccadeBuffer : public TimeStampedRingBuffer{	float *sx, *sy, *ex, *ey;	int *counts;	int current_count;	public:				SaccadeBuffer(int bufsize) : TimeStampedRingBuffer(bufsize){					current_count = 0;					sx = (float *)calloc(buffer_size, sizeof(float));			sy = (float *)calloc(buffer_size, sizeof(float));			ex = (float *)calloc(buffer_size, sizeof(float));			ey = (float *)calloc(buffer_size, sizeof(float));						counts = (int *)calloc(buffer_size, sizeof(int)); 			//time = (long *)calloc(buffer_size, sizeof(long)); 						for(int i = 0; i < buffer_size; i++){							sx[i] = 0;				sy[i] = 0;				ex[i] = 0;				ey[i] = 0;				counts[i] = 0;				//time[i] = 0;			}		}		void buffer(float _sx, float _sy, float _ex, float _ey, long _time){				sx[current_index] = _sx;			sy[current_index] = _sx;			ex[current_index] = _sx;			ey[current_index] = _sx;			counts[current_index] = current_count++;			time[current_index] = _time;			advance();		}};class EyeSampleBuffer : public TimeStampedRingBuffer {	public:		float *x, *y, *dxdt, *dydt, *speed, *direction, *filtered_dxdt, *filtered_dydt, *filtered_speed, *filtered_direction;		BoxCarFilter *velocity_filter;		//long *time;		EyeSampleBuffer(int bufsize) : TimeStampedRingBuffer(bufsize){					x = (float *)calloc(buffer_size, sizeof(float));			y = (float *)calloc(buffer_size, sizeof(float));			dxdt = (float *)calloc(buffer_size, sizeof(float));			dydt = (float *)calloc(buffer_size, sizeof(float));			speed = (float *)calloc(buffer_size, sizeof(float));			direction = (float *)calloc(buffer_size, sizeof(float));			filtered_dxdt = (float *)calloc(buffer_size, sizeof(float));			filtered_dydt = (float *)calloc(buffer_size, sizeof(float));			filtered_speed = (float *)calloc(buffer_size, sizeof(float));			filtered_direction = (float *)calloc(buffer_size, sizeof(float));					//time = (long *)calloc(buffer_size, sizeof(long)); 						for(int i = 0; i < buffer_size; i++){							x[i] = 0;				y[i] = 0;								dxdt[i] = 0;				dydt[i] = 0;				speed[i] = 0;				direction[i] = 0;								filtered_dxdt[i] = 0;				filtered_dydt[i] = 0;				filtered_speed[i] = 0;				filtered_direction[i] = 0;			}						velocity_filter = new BoxCarFilter(50, false);  // TODO: insert sensible values here		}				void buffer(float _x, float _y, long _time){					x[current_index] = _x;			y[current_index] = _y;			time[current_index] = _time;						float dt = time[current_index] - time[previous_index];						dxdt[current_index] = (x[current_index] - x[previous_index])/ dt;			dydt[current_index] = (y[current_index] - y[previous_index]) / dt;			speed[current_index] = sqrt(dxdt[current_index] * dxdt[current_index]  +  dydt[current_index] *dydt[current_index]);			direction[current_index] = atan2(dxdt[current_index], dydt[current_index]);						filtered_dxdt[current_index] = velocity_filter->filter(this, dxdt);			filtered_dydt[current_index] = velocity_filter->filter(this, dydt);						filtered_speed[current_index] = sqrt(filtered_dxdt[current_index]*filtered_dxdt[current_index] + filtered_dydt[current_index]*filtered_dydt[current_index]);			filtered_direction[current_index] = atan2(filtered_dxdt[current_index], filtered_dydt[current_index]);						advance();					}		};// object for computing and storing eye status data// contains ring buffers contain eye sample data, saccade info, etc. class EyeStatus{	protected:				// Eye status contains a series of buffers for storing eye sample information		// SACCADE BUFFER:		// stores the start and end of recent saccades in a ring buffer.		// all values are in degrees 		// these are parallel ring buffers of the last sacbuf_size saccades		SaccadeBuffer *saccade_buffer;		// EYE SAMPLE BUFFER:		// stores recent eye sample data so that we can compute saccade states, etc.		EyeSampleBuffer *eye_sample_buffer;		public:					EyeStatus(int _sacbuf_size = 300, int _eyesampbuf_size = 40){						saccade_buffer = new SaccadeBuffer(_sacbuf_size);						eye_sample_buffer = new EyeSampleBuffer(_eyesampbuf_size);		}/*		void initBoxFilter(){					boxWidthSamples = max(1,(short)(allEyeParams.eyeFilterBoxcarWidthMS/sampleIntervalMS));			if (boxWidthSamples >= MAX_LOOK_BACK_SAMPLES) {				boxWidthSamples = MAX_LOOK_BACK_SAMPLES-1;				mprintf("BOXCAR FILTER width too wide for array: clipped at %d samples = %.1f msec", boxWidthSamples,boxWidthSamples*sampleIntervalMS); 			} else {				mprintf("BOXCAR FILTER width set at %d samples = %.1f msec", boxWidthSamples,boxWidthSamples*sampleIntervalMS);			}						lookBackSamples = max( ((short)((float)LOOK_BACK_MS/deltaMS)),  MAX_LOOK_BACK_SAMPLES-1);  				// LOOK_BACK_MS is time when may want to check for earlier values (e.g. direction change, etc.)											boxFilterChanged = false;			first = false;			newSampleInterval = false;		}						// borrowed from Dlab Eye State.c		static void eyeCompute(long JJD_sampleTime, float sampleIntervalMS, DOUBLE_POINT eyeLocDeg, Boolean markEvents)		{						//register float  deltaMS;		 	long deltaMS;		 			static Boolean 	prediction = false;   // no prediction generated			DOUBLE_POINT 	overshoot;			double  eyeDirection;			short	lookBackSamplesToActual;			short i;			static short boxWidthSamples;			static Boolean first = true;			static Boolean getPeak;			static short	down;			float lengthToPeak;			static DOUBLE_POINT peakLoc;			DOUBLE_POINT  DeyeLocFiltered;						double 				eyeSpeedUnfiltered;			DOUBLE_POINT 		eyeVelocityUnfiltered;			static DOUBLE_POINT eyeLocLastUnfiltered;			short 				eyeSpeedInt,eyeSpeedUnfilteredInt;			DOUBLE_POINT		xx;									// checking for door open  (huh?)			static short nConsecutiveInvalid = 0;			static short nConsecutiveValid = 0;						static float sampleIntervalMSlast;			bool newSampleInterval = false;			/////////////////////			// CHECK FOR CHANGES			/////////////////////									// set a flag if there is a new sample interval			if (sampleIntervalMS != sampleIntervalMSlast) {				mprintf("new sample interval detected");				newSampleInterval = true;			}			sampleIntervalMSlast = 	sampleIntervalMS;										deltaMS = JJD_sampleTime - eye_sampbuf_time[eye_sampbuf_current_index];				//deltaMS = (float)(JJD_sampleTime-timeLast);		// the args are integers, but may be shorts eventually  -- (DDC: Why? we're not on an Apple IIe here...)			if (deltaMS <=0){				 return;						// JJD_sampleTime not running yet			}						if(boxFilterChanged || newSampleInterval){				initBoxFilter();			}									//////////////////////			// APPLY DIGITAL FILTER			//////////////////////			// apply eye sample filter and update the eye filtered value			if (useDigitalFilterOnEyeSamples) {				// each digital filter will maintain its own buffer of previous input and output values				DeyeLocFiltered.h = (double)(eyeLocDeg.h); 					DeyeLocFiltered.v = (double)(eyeLocDeg.v);				DeyeLocFiltered = digital_filter(B_LP125, A_LP125, LP125_ORDER, DeyeLocFiltered, eyeLocStoreInputLP125,eyeLocStoreOutputLP125 );				if (useNotch60)  DeyeLocFiltered = digital_filter(B_N60, A_N60, N60_ORDER, DeyeLocFiltered, eyeLocStoreInputN60,eyeLocStoreOutputN60);				if (useNotch75)  DeyeLocFiltered = digital_filter(B_N75, A_N75, N75_ORDER, DeyeLocFiltered,  eyeLocStoreInputN75,eyeLocStoreOutputN75);				if (useNotch180) DeyeLocFiltered = digital_filter(B_N180, A_N180, N180_ORDER, DeyeLocFiltered, eyeLocStoreInputN180,eyeLocStoreOutputN180);				eyeLocFiltered.h = (float)(DeyeLocFiltered.h); 					eyeLocFiltered.v = (float)(DeyeLocFiltered.v);			}	else {// do boxcar				eyeLocFiltered = boxcar_filter(boxWidthSamples, eyeLocDeg, eyeLocStore);  	// eyeLocStore is a buffer of RAW eye samples,updated by this routine									// (this imposes a lag = allEyeParams.eyeFilterBoxcarWidthMS/2)			}												////////////////////////////			//  BUFFER FILTERED EYE POS			////////////////////////////						//eyeLocBuffer(eyeLocFiltered);			// will buffer last (lookBackSamples) samples			bufferEyeSample(eyeLocFiltered.h, eyeLocFiltered.v);  // my version, computes velocity automatically, also does boxcar filtering									////////////////////////////////////			// COMPUTE INSTANTANEOUS-ISH VELOCITY			////////////////////////////////////								if (deltaMS>0) {					eyeVelocity.h = (eyeLocFiltered.h-eyeLocLast.h)/deltaMS;  // positive = rightward					eyeVelocity.v = (eyeLocFiltered.v-eyeLocLast.v)/deltaMS;  // positive = upward										// unfiltered velocity (for testing of filter)					eyeVelocityUnfiltered.h = (eyeLocDeg.h-eyeLocLastUnfiltered.h)/deltaMS;  // positive = rightward					eyeVelocityUnfiltered.v = (eyeLocDeg.v-eyeLocLastUnfiltered.v)/deltaMS;  // positive = upward				}				else {					eyeVelocity.h = eyeVelocity.v = eyeVelocityUnfiltered.h = eyeVelocityUnfiltered.v = 0;				}*/							//////////////////////////////////////			//  FILTER VELOCITY			//////////////////////////////////////									//update filtered velocity and return current filtered value (this imposes a lag = allEyeParams.eyeFilterBoxcarWidthMS/2)	//			eyeVelocityFiltered = boxcar_filter(boxWidthSamples,eyeVelocity, eyeVelocityStore);				// note: the eye velocity that is used to detect saccades has been filtered twice:					// 1 = filtering of "raw" eye samples (after conversion to degs) --> these are used to estimate eye Velocity					// 2 = filtering of eyeVelocity							////////////////////////////////////			// DETERMINE EYE SPEED AND DIRECTION			// AND BUFFER THEM			////////////////////////////////////									// determine current eye velocity parameters  	/*			eyeSpeed = magnitude(eyeVelocityFiltered,fpointNull);			// absolute mag (i.e. mag relativew to 0)				eyeSpeedUnfiltered = magnitude(eyeVelocityUnfiltered, fpointNull);		// completely unfiltered eye velocity								if ((markEvents) && (recordEyeSpeed)) {					eyeSpeedInt =  round(eyeSpeed*1000.);					// eye speed in nearest degs/sec					eyeSpeedUnfilteredInt =  round(eyeSpeedUnfiltered*1000);					putEvent5("EyeSpeed", (char *)&eyeSpeedInt, NULL);					putEvent5("EyeSpeedUnfilt", (char *)&eyeSpeedUnfilteredInt, NULL);									}								eyeDirection = (float)(phase(eyeVelocityFiltered,eyeVelocityLast));		// direction from last sample				eyeDirectionBuffer(eyeDirection);			// will buffer last (lookBackSamples) direction samples				//statusBuffer(status);						//  "	"		"		"			  status samples		*/									////////////////////////////////////			//  DETERMINE EYE "STATE"			//			//	FIXATED, SACCADING			//			////////////////////////////////////					/*				// determine current eye state  						if (resetMS>0) {			// note -- a reset of sorts is built in to the saccade compute end 					eyeState = FIXATED; 					resetMS = resetMS - deltaMS;				} else {		// reset from last saccade end has completed and not at trial start -- return to monitoring eyeState changes						// hysteresis built in here					if ( eyeSpeed <= sacEndSpeedDegPerMS) {			// 5,3  units per msec is about right ! = approx 14,9 deg / sec						eyeState = FIXATED;					}						else if  (eyeSpeed > sacStartSpeedDegPerMS){						eyeState = SACCADING;						}					// else eye state is same as last state.				}								if (trialStart) {					if  ((JJD_sampleTime > LOOK_BACK_MS ) && (eyeState == FIXATED)) {		// eye is fixated after trial start, begin checking						trialStart = false;						checkForSaccadeStart = true;					}				}												if (checkForSaccadeStart) {											if ((eyeState == SACCADING) && (eyeStateLast == FIXATED)) {		// saccade start												//sacDetectedStartLoc = eyeLocFiltered;						//sacData.sacDetectedStartTime = JJD_sampleTime;						// determine "actual" start time and location by looking back for direction change						// if no direction change detected, will look back to lookBackSamples = time of LOOK_BACK_MS (hard msec limit)						for (i=1;i<=lookBackSamples;i++) {		// sample 1 == Last sample, sample 0 = current sample 							lookBackSamplesToActual = i;								if (fabs(bufferDirection[i] - bufferDirection[0]) > sacStartDirectionChangeDeg) {								i=lookBackSamples+1;	// break look							}						}												sacData.sacDetectedStartTime = JJD_sampleTime - (short)(((float)lookBackSamplesToActual)*deltaMS);						sacData.sacDetectedStartLoc.h = bufferLoc[lookBackSamplesToActual].h;	// location (10 msec) before current time						sacData.sacDetectedStartLoc.v = bufferLoc[lookBackSamplesToActual].v;	// location (10 msec) before current time						//sacData.statusSaccadeStart = bufferStatus[lookBackSamplesToActual];	// save the status (when sac started)												// compute piecewise amplitude from "actual" start location (time)  to (last eye loc sample - 1)						sacAmplitudePiecewise = 0;						for (i=lookBackSamplesToActual;i>=2;i--) {		// sample 1 == EyeLocLast, sample 0 = eyeLoc (current0 							sacAmplitudePiecewise = sacAmplitudePiecewise + magnitude(bufferLoc[i],bufferLoc[i-1]);						}						sacPeakSpeed = 0;						sacBeyondVelocityPeak = false;						//samplesPastPeak = 0;						//timer = 0;						//timerRunning = false;						getPeak = true;						down = 0;						inSaccade = true;						checkForSaccadeStart = false;						checkForSaccadeEnd = true;													if (markEvents) {								putEvent5("SaccadeStart", NULL, NULL);						}							//ITC_DigitalBitsOn(0x04);											}				}											//////////////////////////////////////////////			// UPDATE sacAmplitudePiecewise, sacPeakSpeed				// PREDICT saccade end point based on velocity profile			///////////////////////////////////////////////									if (inSaccade) {		// still in saccade					sacAmplitudePiecewise = sacAmplitudePiecewise + magnitude(eyeLocLast,eyeLocFiltered);					if (eyeSpeed>=sacPeakSpeed) {						sacPeakSpeed = eyeSpeed;						peakLoc = eyeLocFiltered;					}					if (eyeSpeed<eyeSpeedLast) 						down++;					else						down = 0;					if ( (down>=2) && getPeak) {		// need 2 consecutive decreases in speed to decide peak has passed						sacBeyondVelocityPeak = true;						sacData.peakDetected = true;						xx.h = sacData.sacDetectedStartLoc.h;						xx.v = sacData.sacDetectedStartLoc.v;						lengthToPeak = magnitude(xx,eyeLocFiltered);						sacData.peakBasedPredictedLengthDeg =  lengthToPeak +  (lengthToPeak * PEAK_BASED_PREDICTION_MULTIPLIER); 						// crude predicted landing location						sacData.peakBasedPredictedEyeLoc.h = peakLoc.h + 																	((peakLoc.h - sacData.sacDetectedStartLoc.h) * PEAK_BASED_PREDICTION_MULTIPLIER); 						sacData.peakBasedPredictedEyeLoc.v = peakLoc.v + 																	((peakLoc.v - sacData.sacDetectedStartLoc.v)* PEAK_BASED_PREDICTION_MULTIPLIER);																		getPeak = false;					}				}							/////////////////////////////////////			// CHECK IF SACCADE IS OVER			// SIGNAL TO CHECK RESPONSE WINDOWS			/////////////////////////////////////								if (checkForSaccadeEnd) {										if ( (eyeState == FIXATED) && (eyeStateLast == SACCADING)) {		// saccade end											goCheckResponseWindows = true;			// will check if next sample has triggered any response windows						//printf(" sac ENDING: sacNum = %d  end time = %ld \n",sacNum,JJD_sampleTime);						sacData.sacDetectedEndTime =  JJD_sampleTime;	//TODO -- these times should be same as pEvent times !!!						sacData.durationMS = sacData.sacDetectedEndTime - sacData.sacDetectedStartTime;						sacData.sacDetectedEndLoc.h = eyeLocFiltered.h;						sacData.sacDetectedEndLoc.v = eyeLocFiltered.v;												if (!sacBeyondVelocityPeak) {			// peak not detected							//mprintf("WARNING: missed peak");							sacData.peakBasedPredictedEyeLoc.h = 0;		// -- no prediction available: task system will effectively ignore this saccade							sacData.peakBasedPredictedEyeLoc.v = 0;							sacData.peakBasedPredictedLengthDeg = 0;							sacBeyondVelocityPeak = true;		// allows task system to continue !!! -- DO NOT REMOVE !!!							sacData.peakDetected = false;						}						sacData.peakSpeedDegPerSec = sacPeakSpeed*1000.;		// now in Deg per Sec												// prepare to compute "final" position						sacData.sacTrueEndLoc.h = sacData.sacTrueEndLoc.v = 0;						checkForSaccadeEnd = false;						inSaccade = false;						computeSacTrueEnd = true;						timeSinceSacDetectedEnd = 0;						c = 0;						resetMS = RESET_MS;			// assume another sac cannot occur in next RESET_MS msec;						if (markEvents) {								putEvent5("SaccadeEnd", NULL, NULL);						}						//ITC_DigitalBitsOff(0x04);																		if (erasing) {		// this is for testing only (TODO)							nSacsEndedBeforeEraseComplete++;							duration = sacData.durationMS;							if (markEvents) {									errorValue = SAC_ENDED_BEFORE_ERASE_FINISHED;									//putEvent5("ERROR", (char *)&errorValue, NULL);							}						}						*/											/*						}					}*/											///////////////////////////////////////			// COMPUTE LOCATION OF END OF SACCADE				//			// (an average of eye location at end of saccade			//			/////////////////////////////////////////					/*								if (computeSacTrueEnd) {		// this will carry over several samples (compute average loc over DURATION msec)					sacAmplitudePiecewise = sacAmplitudePiecewise + magnitude(eyeLocLast,eyeLocFiltered); // continue computing amp					timeSinceSacDetectedEnd = timeSinceSacDetectedEnd + deltaMS;					if ((timeSinceSacDetectedEnd >= TRUE_END_DELAY_MS) &&						 (timeSinceSacDetectedEnd <= (TRUE_END_DELAY_MS + TRUE_END_DURATION_MS) )) {   // assume DELAY msec after detected end is "true" end						c++;						sacData.sacTrueEndLoc.h = sacData.sacTrueEndLoc.h + eyeLocFiltered.h;						sacData.sacTrueEndLoc.v = sacData.sacTrueEndLoc.v + eyeLocFiltered.v;					}					if (timeSinceSacDetectedEnd > (TRUE_END_DELAY_MS + TRUE_END_DURATION_MS) ) {									computeSacTrueEnd = false;							checkForSaccadeStart = true;							sacData.sacTrueEndLoc.h = sacData.sacTrueEndLoc.h/(float)c;							sacData.sacTrueEndLoc.v = sacData.sacTrueEndLoc.v/(float)c;							sacData.distancePieceDeg = sacAmplitudePiecewise;							sacData.distanceDeg = magnitudeF(sacData.sacTrueEndLoc, sacData.sacDetectedStartLoc);														overshoot.h = (sacData.sacTrueEndLoc.h - sacData.sacDetectedEndLoc.h);							overshoot.v = (sacData.sacTrueEndLoc.v - sacData.sacDetectedEndLoc.v);							if (sacPeakVelocity.h < 0) overshoot.h = -1.*overshoot.h; 							if (sacPeakVelocity.v < 0) overshoot.v = -1.*overshoot.v; 							sacData.overshootDistDeg.h = overshoot.h;							sacData.overshootDistDeg.v = overshoot.v;															if ((sacData.distanceDeg <  allEyeParams.minSacAmplitudeDeg) || 								(sacData.durationMS < allEyeParams.minSacDurationMS ) ){ // -- not counted as a saccade								if (markEvents) {										putEvent5("SaccadeInvalid", NULL, NULL);	// will end plotting								}														}							else { 	// "valid" saccade																	// ISI computation								if (sacDetectedStartTimeLast != 0) {									sacData.timeSinceLastMS = sacData.sacDetectedStartTime - sacDetectedStartTimeLast;									sacData.latencyMS = sacData.sacDetectedStartTime - sacDetectedEndTimeLast;								}								else {									sacData.timeSinceLastMS = 0;		// unknown -- current saccade is first in trial								}																			if (markEvents) {									putEvent5("SaccadeData", (char *)&sacData, NULL);								}																								sacDetectedStartTimeLast = sacData.sacDetectedStartTime;								sacDetectedEndTimeLast = sacData.sacDetectedEndTime;								durationLast =  sacData.durationMS;							}													}								}					///////////////////////////////////				// CLEAN UP		///////////////////////////////////			// prepare for next call			eyeStateLast = eyeState;			eyeLocLast = eyeLocFiltered;			// saves last filtered value			eyeLocLastUnfiltered = eyeLocDeg;		// saves last raw value			timeLast = JJD_sampleTime;			eyeVelocityLast = eyeVelocityFiltered;			eyeSpeedLast = eyeSpeed;			if (prediction) {					eyeAccelLast = eyeAccel;			}	*/		};// a globally defined function so that we may schedule itvoid updateEyeTriggers();		#endif